#!/usr/bin/env bash

set -euo pipefail

SCRIPT_NAME="$(basename "$0")"

show_help() {
    cat << EOF
Usage: $SCRIPT_NAME <command>
       $SCRIPT_NAME -h | --help

Display the source code of a command/script if it is a readable text file (e.g., shell, Python, Perl script).

Refuses to display compiled binaries to avoid garbled terminal output.

Examples:
  $SCRIPT_NAME cash        # Show this script
  $SCRIPT_NAME my-script   # Show a script in PATH
  $SCRIPT_NAME ls          # Warn: ls is a binary

Options:
  -h, --help    Show this help message and exit
EOF
}

# Handle help first
if [[ $# -eq 1 && ("$1" == "-h" || "$1" == "--help") ]]; then
    show_help
    exit 0
fi

if [[ $# -ne 1 ]]; then
    echo "Error: Exactly one command name required." >&2
    echo "Try '$SCRIPT_NAME --help' for usage." >&2
    exit 1
fi

COMMAND="$1"
COMMAND_PATH="$(which "$COMMAND" 2>/dev/null)" || {
    echo "Error: '$COMMAND' not found in PATH." >&2
    exit 1
}

if [[ ! -f "$COMMAND_PATH" ]]; then
    echo "Error: '$COMMAND_PATH' is not a regular file." >&2
    exit 1
fi

if [[ ! -r "$COMMAND_PATH" ]]; then
    echo "Error: '$COMMAND_PATH' is not readable." >&2
    exit 1
fi

# Detect if it's a text file using `file`
if file -b --mime-type "$COMMAND_PATH" | grep -qE '^text/|^application/x-shellscript|^inode/x-empty|^application/x-empty'; then
    echo "# Source of '$COMMAND' ($COMMAND_PATH):"
    echo
    cat "$COMMAND_PATH"
elif file "$COMMAND_PATH" | grep -qE 'script|interpreted'; then
    # Some scripts are detected as "data" but file mentions "script"
    echo "# Source of '$COMMAND' ($COMMAND_PATH):"
    echo
    cat "$COMMAND_PATH"
else
    echo "'$COMMAND' is a compiled binary or non-text file."
    echo "Displaying it would produce garbage and could mess up your terminal."
    echo "Location: $COMMAND_PATH"
    echo
    echo "Tip: Use 'file \"$COMMAND_PATH\"' or 'objdump -h \"$COMMAND_PATH\"' for more info."
    exit 1
fi